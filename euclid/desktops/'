package manager

import (
	"log"
	"net"
	"os"
	"os/signal"
	"syscall"

	"github.com/BurntSushi/xgb"
	"github.com/BurntSushi/xgb/xproto"
	"github.com/thrisp/scpwm/euclid/branch"
	"github.com/thrisp/scpwm/euclid/clients"
	"github.com/thrisp/scpwm/euclid/commander"
	"github.com/thrisp/scpwm/euclid/desktops"
	"github.com/thrisp/scpwm/euclid/handler"
	"github.com/thrisp/scpwm/euclid/monitors"
	"github.com/thrisp/scpwm/euclid/ruler"
	"github.com/thrisp/scpwm/euclid/settings"
)

type Manager struct {
	*log.Logger
	handler.Handler
	settings.Settings
	*Loops
	ruler.Ruler
	commander.Commander
	*branch.Branch
	//history  *History
}

func New() *Manager {
	l := newLoops()

	m := &Manager{
		Settings:  settings.DefaultSettings(),
		Ruler:     ruler.New(),
		Commander: commander.New(l.Comm),
		Logger:    log.New(os.Stderr, "[SCPWM] ", log.Ldate|log.Lmicroseconds),
	}

	hndl, err := handler.New("", settings.EwmhSupported, m.Logger)
	if err != nil {
		panic(err)
	}
	m.Handler = hndl
	m.SetEventFns()

	m.Branch = monitors.New(m.Handler, m.Settings)

	m.Loops = l

	return m
}

type Loops struct {
	Pre  chan struct{}
	Post chan struct{}
	Quit chan struct{}
	Comm chan string
	Sys  chan os.Signal
}

func newLoops() *Loops {
	return &Loops{
		make(chan struct{}, 0),
		make(chan struct{}, 0),
		make(chan struct{}, 0),
		make(chan string, 0),
		make(chan os.Signal, 0),
	}
}

func (m *Manager) Looping(l *net.UnixListener) *Loops {
	lp := m.Loops

	go func() {
		m.Commander.Listen(l, m)
	}()

	go func() {
		m.Handler.Handle(lp.Pre, lp.Post, lp.Quit)
	}()

	signal.Notify(
		lp.Sys,
		syscall.SIGINT,
		syscall.SIGHUP,
		syscall.SIGTERM,
		syscall.SIGCHLD,
		syscall.SIGPIPE,
	)

	return lp
}

func (m *Manager) SignalHandler(sig os.Signal) {
	switch sig {
	case syscall.SIGINT, syscall.SIGHUP, syscall.SIGTERM:
		m.Println(sig)
		os.Exit(0)
	case syscall.SIGCHLD, syscall.SIGPIPE:
		m.Println(sig)
	}
}

func Current() (monitors.Monitor, desktops.Desktop, clients.Client) {
	return nil, nil, nil
}

func (m *Manager) Tree() *branch.Branch {
	return m.Branch
}

func (m *Manager) Monitors() []monitors.Monitor {
	return monitors.All(m.Branch)
}

func (m *Manager) Desktops() []desktops.Desktop {
	var ret []desktops.Desktop
	ms := m.Monitors()
	for _, mon := range ms {
		ret = append(ret, desktops.All(mon.Desktops())...)
	}
	return ret
}

func (m *Manager) Clients() []clients.Client {
	var ret []clients.Client
	ds := m.Desktops()
	for _, d := range ds {
		ret = append(ret, clients.All(d.Clients())...)
	}
	return ret
}

func (m *Manager) SetEventFns() {
	m.SetEventFn("MapRequest", m.MapRequest)
	m.SetEventFn("DestroyNotify", m.DestroyNotify)
	m.SetEventFn("UnmapNotify", m.UnmapNotify)
	m.SetEventFn("ClientMessage", m.ClientMessage)
	m.SetEventFn("ConfigureRequest", m.ConfigureRequest)
	m.SetEventFn("PropertyNotify", m.PropertyNotify)
	m.SetEventFn("EnterNotify", m.EnterNotify)
	m.SetEventFn("MotionNotify", m.MotionNotify)
	m.SetEventFn("FocusInEvent", m.FocusIn)
	m.SetEventFn("ScreenChange", m.ScreenChange)
}

var EventError = Xrror("Event : %+v is not recognized despite being passed to an appropriate Manager function.").Out

func (m *Manager) MapRequest(evt xgb.Event) error {
	if mr, ok := evt.(xproto.MapRequestEvent); ok {
		m.schedule(mr.Window)
	}
	return EventError(evt)
}

func (m *Manager) exists(win xproto.Window) bool {
	_, exists := m.locate(win)
	return exists
}

func (m *Manager) locate(win xproto.Window) (clients.Client, bool) {
	for _, c := range m.Clients() {
		if c.XWindow() == win {
			return c, true
		}
	}
	return nil, false
}

func (m *Manager) schedule(win xproto.Window) {
	var overrideRedirect bool
	wa, _ := xproto.GetWindowAttributes(m.Conn(), win).Reply()
	if wa != nil {
		overrideRedirect = wa.OverrideRedirect
	}

	if !overrideRedirect && !m.exists(win) {
		rules := m.Ruler.Applicable(win)
		m.manage(win, rules)
	}
}

func (m *Manager) manage(win xproto.Window, rules []ruler.Rule) {
	//mon, desk, f := m.Current()
	//for _, r := range rules {
	//switch r.Effect() {
	//case ruler.IsManaged:
	//case ruler.ClientDescription:
	//mon, desk, f = locate that client as f
	//case ruler.DesktopDescription:
	//mon, desk, f = locate desktop as desk
	//case ruler.MonitorDescription:
	//mon, desk, f = locate monitor as mon
	//case ruler.IsSticky:
	//case ruler.SetSplitDirection:
	//	if f != nil {
	//		//f.splitM = manual
	//		//f.splitd = r.String() to split direction
	//	}
	//case ruler.SetSplitRatio:
	//	if f != nil {
	//		//f.splitR = rule.splitRatio
	//	}
	//}
	//}
	// make client
	// update client rectangle, max widths & heights
	// embrace & translate to monitor

	// add client to the appropriate tree on top of focus

	// adjust rule floating to desktop floating

	// set client state based on rules

	// arrange desktop

	// if visible desktop -- show window

	// update ewmh
	// ewmh_set_wm_desktop(n, d);
	// ewmh_update_client_list();
}

func (m *Manager) ConfigureRequest(evt xgb.Event) error {
	if cr, ok := evt.(xproto.ConfigureRequestEvent); ok {
		client, exists := m.locate(cr.Window)
		var w, h int
		if exists && client.Tiled() {
			//if (cr.ValueMask && xproto.ConfigWindowX {
			//
			//}
			//if cr.ValueMask & xproto.ConfigWindowY {
			//
			//}
			//if cr.ValueMask & xproto.ConfigWindowHeight {
			//
			//}
			//if cr.ValueMask & xproto.ConfigWindowWidth {
			//
			//}
		} else {

		}
		return nil
	}
	return EventError(evt)
}

func (m *Manager) unmanage(win xproto.Window) error {
	return nil
}

func (m *Manager) DestroyNotify(evt xgb.Event) error {
	if dn, ok := evt.(xproto.DestroyNotifyEvent); ok {
		return m.unmanage(dn.Window)
	}
	return EventError(evt)
}

func (m *Manager) UnmapNotify(evt xgb.Event) error {
	if un, ok := evt.(xproto.UnmapNotifyEvent); ok {
		return m.unmanage(un.Window)
	}
	return EventError(evt)
}

func (m *Manager) PropertyNotify(evt xgb.Event) error {
	if pn, ok := evt.(xproto.PropertyNotifyEvent); ok {
		if m.locate(pn.Window) {
			return nil
		}
		return nil
	}
	return EventError(evt)
}

func (m *Manager) ClientMessage(evt xgb.Event) error {
	if cm, ok := evt.(xproto.ClientMessageEvent); ok {
		return nil
	}
	return EventError(evt)
}

func (m *Manager) FocusIn(evt xgb.Event) error {
	if fi, ok := evt.(xproto.FocusInEvent); ok {
		return nil
	}
	return EventError(evt)
}

func (m *Manager) EnterNotify(evt xgb.Event) error {
	if en, ok := evt.(xproto.EnterNotifyEvent); ok {
		return nil
	}
	return EventError(evt)
}

func (m *Manager) MotionNotify(evt xgb.Event) error {
	if mn, ok := evt.(xproto.MotionNotifyEvent); ok {
		return nil
	}
	return EventError(evt)
}

func (m *Manager) ScreenChange(evt xgb.Event) error {
	return monitors.Update(m.Branch, m.Handler, m.Settings)
}
